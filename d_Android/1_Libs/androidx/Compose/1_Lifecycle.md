
### Теория
**Композиция (Composition)** 
	- это рекурсивное дерево, каждый елемент которого есть таким же деревом
	- У каждого Composition свой Lifecycle (вложенные могут умирать раньше)
	- `Composition != @Composable fun`
	- создается и обслуживается композабл функциями. *Сами функции выполняются при каждой рекомпозиции, НО*
	- под капотом проверяется кеш  uiState и перерис. только те, в которых произошли изменения uiState.
	- remember{} кеширует данные ровно пока, живет Композиция в которой он вызвается

Lifecycle - Жизненный цикл объекта композиции:
	- Вход (Создание)
	- Рекомпозиция (посредством композабл функции)
	- Удаление

### Lifecycle  (типа: onCreate, onUpdate,onDestroy)
![[Pasted image 20231220190406.png]]

#### 1. Composition (Композиция)
- **Инициализация**: 
	Превращает @Composables в Composition (набор UI элементов) выполняя эти функции.
- **Создание состояний и подписок**: 
	Строит родительские отношения между компонентами
	Устанавливаются состояния, объекты и подписки.  
	Инициализируются паттерны, `remember` или `LaunchedEffect`

#### 2. Recomposition (Перекомпозиция)
- **Реакция на изменения**: 
	Когда state, от которого зависит `@Composable`, изменяется - функция повторно вызывается с новыми данными.
- **Минимальные изменения**: 
	Compose оптимизирует этот процесс, перекомпонуя только те части интерфейса, которые зависят от изменившегося state.
	
#### 3. Disposal (Уничтожение)
- **Очистка**: Когда `@Composable` функция удаляется из композиции, например, при переходе на другой экран, Compose выполняет очистку. Это включает отмену всех подписок и корутин, запущенных внутри функции.
- **Эффекты уничтожения**: Использование `DisposableEffect` позволяет определить код, который должен быть выполнен при удалении компонента из композиции, что аналогично методу `onDestroy` в жизненном цикле Activity или Fragment.
----------------------------------------------------------------------------
**Интеграция с Lifecycle**: Хотя сами `@Composable` функции не имеют жизненного цикла, они могут быть осведомлены о жизненном цикле внешних контейнеров (например, активити или фрагментов) через специальные API, такие как `LifecycleOwnerAmbient`.

### Rander Phases
**ВАЖНО!**   Можно настроить, что любая из фаз будут пропущены.
 ![[Pasted image 20231221164153.png]]

#### 1. Composition Phase - (что нужно отрисовать?)
  Превращает @Composables в Composition  выполняя эти функции.
  
#### 2. Layout (Расположение элементов.. где отрисовыват?)
- **Расчет размеров**: После композиции или рекомпозиции, рассчитываем размеры и расположение 
	`- считает размеры и позиции компонентов`
	`- Компоновщики спрашивают у вложеных компонентов их размеры`
	`- Компоненты напр. Text, Spaser измеряют себя сами`
- **Определение позиции**: 
	Каждый компонент в дереве UI получает конкретную позицию на экране.
```
.offset{        // выполняется на LayoutPhase фазе
	IntOffset(x=0, y = 20 * (counterValue/3))
}
```

##### derivedStateOf{}
```kotlin
val transformedValue by remember{
	derivedStateOf{
		originState / 3 //
	}
}
```

![[Pasted image 20231221180044.png]]

#### 3. Drawing Phase - (отрисовка)
- **Рендеринг**: 
	Когда все размеры и позиции определены, 
	Compose отрисовывает компоненты на экране.
	Используется графический движок устройства.

**ВАЖНО!** (из GPT4)
**Макетирование и отрисовка следуют за рекомпозицией и связаны с ней (как ее последствия), 
но являются отдельными этапами в процессе рендеринга.**

`.drawBehind{}            // выполняется на DrawingPhase фазе `


### Логирование Lifecycle
```kotlin
private const val TAG = "CompositionLifecycle"  
  
@Composable  
fun logCompositionLifecycle(name: String): Any = remember {  
    LifecycleRememberObserver(name)  
}  
  
private class LifecycleRememberObserver(  
    private val name: String  
): RememberObserver {  
      
    override fun onAbandoned() {  
        Log.d(TAG, "$name.onEnter")  
    }  
	  
    override fun onForgotten() {  
        Log.d(TAG, "$name.onLeave")  
    }  
	  
    override fun onRemembered() = Unit  
}
```
