
### Теория
**Composition** - дерево компонентов созданное @Composable fun
	- `@Composable fun != Composition`
	-  `@Composable fun serve the Composition`
	- `Рекомпозиция перерисовывает только елементы, в которых произошли изменения uiState.`
		 - `Это происходит потому, что Composition рекурсивная структура данных. `
		 - `Каждый компонент сам является Composition.`
		 - `У каждого Composition свой Lifecycle (вложенные могут умирать раньше)` 
	- `remember кеширует данные ровно пока, живет Composition в которой оно вызвано`

### Lifecycle  (типа: onCreate, onUpdate,onDestroy)
![[Pasted image 20231220190406.png]]

#### 1. Composition (Композиция)
- **Инициализация**: 
	Превращает @Composables в Composition (набор UI элементов) выполняя эти функции.
- **Создание состояний и подписок**: 
	Строит родительские отношения между компонентами
	Устанавливаются состояния, объекты и подписки.  
	Инициализируются паттерны, `remember` или `LaunchedEffect`

#### 2. Recomposition (Перекомпозиция)
- **Реакция на изменения**: 
	Когда state, от которого зависит `@Composable`, изменяется - функция повторно вызывается с новыми данными.
- **Минимальные изменения**: 
	Compose оптимизирует этот процесс, перекомпонуя только те части интерфейса, которые зависят от изменившегося state.
	
#### 3. Disposal (Уничтожение)
- **Очистка**: Когда `@Composable` функция удаляется из композиции, например, при переходе на другой экран, Compose выполняет очистку. Это включает отмену всех подписок и корутин, запущенных внутри функции.
- **Эффекты уничтожения**: Использование `DisposableEffect` позволяет определить код, который должен быть выполнен при удалении компонента из композиции, что аналогично методу `onDestroy` в жизненном цикле Activity или Fragment.
----------------------------------------------------------------------------
**Интеграция с Lifecycle**: Хотя сами `@Composable` функции не имеют жизненного цикла, они могут быть осведомлены о жизненном цикле внешних контейнеров (например, активити или фрагментов) через специальные API, такие как `LifecycleOwnerAmbient`.

### Rander Phases
**ВАЖНО!**   Можно настроить, что любая из фаз будут пропущены.
 ![[Pasted image 20231221164153.png]]

#### 1. Composition Phase - (что нужно отрисовать?)
  Превращает @Composables в Composition  выполняя эти функции.
  
#### 2. Layout (Расположение элементов.. где отрисовыват?)
- **Расчет размеров**: После композиции или рекомпозиции, рассчитываем размеры и расположение 
	`- считает размеры и позиции компонентов`
	`- Компоновщики спрашивают у вложеных компонентов их размеры`
	`- Компоненты напр. Text, Spaser измеряют себя сами`
- **Определение позиции**: 
	Каждый компонент в дереве UI получает конкретную позицию на экране.
```
.offset{        // выполняется на LayoutPhase фазе
	IntOffset(x=0, y = 20 * (counterValue/3))
}
```

##### derivedStateOf{}
```kotlin
val transformedValue by remember{
	derivedStateOf{
		originState / 3 //
	}
}
```

![[Pasted image 20231221180044.png]]


#### Drawing Phase - (отрисовка)
- **Рендеринг**: 
	Когда все размеры и позиции определены, 
	Compose отрисовывает компоненты на экране.
	Используется графический движок устройства.

**ВАЖНО!** (из GPT4)
**Макетирование и отрисовка следуют за рекомпозицией и связаны с ней (как ее последствия), но являются отдельными этапами в процессе рендеринга.**

`.drawBehind{}            // выполняется на DrawingPhase фазе `




### Log composable livecycle
```kotlin
private const val TAG = "CompositionLifecycle"  
  
@Composable  
fun logCompositionLifecycle(name: String): Any = remember {  
	LifecycleRememberObserver(name)  
}  
  
private class LifecycleRememberObserver(  
	private val name: String,  
) : RememberObserver {  
	override fun onAbandoned() = Unit  
  
	override fun onForgotten() {  
		Log.d(TAG, "$name.onLeave")  
	}  
  
	override fun onRemembered() {  
		Log.d(TAG, "$name.onEnter")  
	}  
}
```

