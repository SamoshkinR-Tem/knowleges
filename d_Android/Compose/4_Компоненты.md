
### ComposeView  :  AbstractComposeView   :  ViewGroup(context, attrs, defStyleAttr)
```kotlin
class MainActivity : ComponentActivity() {  
	override fun onCreate(savedInstanceState: Bundle?) {  
		super.onCreate(savedInstanceState)  
		setContent {}  // запускает отрисовку ComposeView 
	}
}
```

### Get Context
```kotlin
@Composable
fun showToast(){
	val context: Context = LocalContext.current
	Toast.makeText(
		context,
		"Hello world",
		Toast.LENGTH_SHORT
	).show()
}
```

### Preview
```kotlin
@Composable  
@Preview(
	showSystemUi = true,   
	widthDp = 100,                    // можно указывать вместе с showSystemUi
	heightDp = 600          
	showBackground = true,
	)
private fun PreviewScreenContent() {  // any fun name
	ScreenContent(                    // name of real compose fun
		uiState = MyState(),               
	)  
}
```

### Modifier  -  декорирование, клики, прокрутка...
- Это интрфейс, на который навешивают extension функции.
- Можно создавать свои extension для модификатора
- Обрабатывается:
	- Компоновщиком (как :layout_ атрибуты в xml)         или
	- ComposeView ()
- **ВАЖНО** соблюдать правильную очередность вызовов функций
	 ![[Pasted image 20231219174853.png]]
  
```kotlin
modifier = Modifier                  // ВАЖНО соблюдать очередность
			.align(BiasAlignment.Horizontal(0.2f))  // смещение как в ConstraintLayout
			.background(
				color= Color.Green,  // цвет фона
				shape=CircleShape, // форма фона
			)
			.clip(CircleShape)       // обрезка типа crop 
			.clickable(              // обработка кликов
				onClick = {},
				interactionSource = MutableInteractionSource(),
				indication = rememberRipple(),
			)            
			.fillMaxSize()           // занять все место в родителе
			.fillMaxWidth(0.5f)      // займет половину родителя
			.offset(40.dp, 40.dp)    // как бывший padding но территоря та же
			.offset{                 // выполняется на LayoutPhase фазе (cм. Lifecycle)
				IntOffset(x=0, y = 20 * (counterValue/3))
			}
			.drawBehind{}            // выполняется на DrawingPhase фазе 
			.padding(16.dp)          // как бывший marging
			.pinterInput(Unit){      // обработка любых событий: перетягивания, кликов
				detectDrag...{}
			}
			.size(64.dp)
			.verticalScroll(rememberScrollState()) // прокрутка
			.weight(2f)              // аналог weight у LinearLayout

			// прокидываем modifierв свой кастомный компонент
@Composable
fun MyComponent(
	modifier: Modifier = Modifier,
	width: Dp = 100.dp,
	height: Dp = 100.dp,
){
	Box(modifier.then(
		Modifier
			.size(width, height)
		))
}
```

### Компоновщики
#### Box  -  только contentAlignment (center или по углам)
```kotlin
Box(
	modifier = Modifier.fillMaxSize(),
	contentAlignment = Alignment.Center,
)
```

#### BoxWithConstraints
```kotlin
BoxWithConstraints(modifier = Modifier.fillMaxSize()) {  
	val offsetX = (constraints.maxWidth*0.08).roundToInt()  
	Column(  
		modifier = Modifier  
		.offset(x = offsetX.dp, y = 0.dp)
	)
}
```

#### Card  -  аналог CardView
```kotlin
	Card(modifier = Modifier.fillMaxSize(),
		shape = RoundedCornerShape(12.dp),  
		border = BorderStroke(1.dp, Color.Gray),
		elevation = 5.dp
	){}
```

#### Row -  content рядком (аналог LinearLayout horisontal)
```kotlin
	Row(modifier = Modifier.fillMaxSize()
			.padding(16.dp)
			.background(Color.Green)
			.fillMaxWidth(0.5f),
		verticalAlignment = Alignment.Bottom,
							= BiasAlignment.Vertucal(-0.8),          // от -1 (влево) до 1 (вправо)
							= BiasbsoluteAlignment.Vertical(0.8),    // игнорит локализацию (rtl)
		horizontalArrangement = Arrangement.Center,
							= Arrangement.End,
							= Arrangement.SpaceBetween,  // пробелы между елементами
							= Arrangement.SpaceEvenly,   // пробелы между и вокру елементов (равные)
							= Arrangement.SpaceAround,   // пробелы между и вокру елементов (у краев в 2 раза меньше)
	){ Text(text = pictureName) }
```

#### Column  -  грузит в память ВСЕ елементы списка (и видимые и НЕ видимые)
```kotlin
	Column( 
		modifier = Modifier
			.fillMaxSize()
			.verticalScroll(rememberScrollState()),
		horizontalAlignment = Alignment.Bottom,
							= BiasAlignment.Horisontal(-0.8),          // от -1 (влево) до 1 (вправо)
							= BiasbsoluteAlignment.Horisontal(0.8),    // игнорит локализацию (rtl)
		verticalArrangement = Arrangement.Center,
							= Arrangement.End,
							= Arrangement.SpaceBetween,  // пробелы между елементами
							= Arrangement.SpaceEvenly,   // пробелы между и вокру елементов (равные)
							= Arrangement.SpaceAround,   // пробелы между и вокру елементов (у краев в 2 раза меньше)
	){ Text(text = pictureName) }
```

#### LazyColumn (LazyRow)  -  грузит в память ТОЛЬКО видимые елементы
```kotlin
	LazyColumn(modifier = Modifier 
		.fillMaxSize() //по дефолту имеет verticalScroll
		.background(primaryColor)
	){
		// добавлем 1 елемент, напр.: "Заголовок" который прокрутится и не будет видно
		item{ Text("Header", 20.sp) }  
		
		// Заголовок который прокрутится до края и остается виден.
		// Можно использовать несколько таких заголовков
		stickyHeader { Text("Sticky Header") }
		
		//variant1
		items(count = 15) {           // сюда можно передавать listOf("Hello", "World")
			Text(text = "Item $it")   // "it" is item index
		}
		
		//variant2
		items(
			items = userList,
			key = { user -> user.id }  // оптимизирует работу LazyColumn (опционально)
		) {      
			UserCard(){ ... }          
		}
		
		//variant3
		itemsIndexed(
			listOf("Hi", "Hello", "World")
		){ index, item ->
			Text(text = item + $index)
		}
	}
```

для проверки скорости работы LazyColumn:
~ build.gradle
```kotlin
	buildTypes {
		...
		create("test") {
			initWith(getByName("debug"))
			isDebuggable = false
			isProfileable = true
		}
	}
```

#### Scaffold
```kotlin

Scaffold(
    topBar = { 
	    TopAppBar(
		    title = { Text( ... ) },
		    navigationIcon = { IconButton() },
		    actions = {
			    IconButton( onClick = {} ){
				    Icon( imageVextor = Icon.Default.Settings, )
			    }
			    IconButton( onClick = {} ){
				    Icon( imageVextor = Icon.Default.MoreVert, )
			    }
		    },
		    colors = TopAppBarDefaults.largeTopAppBarColors( 
				containerColor = MaterialTheme.colorScheme.primaryContainer,
				titlerContentColor = MaterialTheme.colorScheme.onPrimaryContainer, // цвет контрастный primaryContainer (чтоты видно было)
				navigationIconContentColor = Color.Red,
				actionIconContentColor = Color.Red,
			),
	    ){} 
	},
    floatingActionButton = {
		FloatingActionButton( onClick = {} ){
			Icon( imageVector = Icons.Default.Add, )
		}
	},
	floatingActionButtonPosition = FabPosition.End,
	snackbarHost = {},
	bottomBar = {
		// BottomAppBar {}
		NavigationBar {
			NavigationBarItem()
			NavigationBarItem()
		}
	},
) { paddingValues ->
	// main content
	Box(
		modifier = Modifier
			.padding(paddingValues)
			.fillMaxSize()
	){ ... }
}
```

#### TopAppBar  - [супер видео](https://www.youtube.com/watch?v=KJ_VOSGtaZ8)
```kotlin
class MainActivity : ComponentActivity() {  
	override fun onCreate(savedInstanceState: Bundle?) {  
		super.onCreate(savedInstanceState)
		enableEdgeToEdge()  //раздвигает границы app под системные statusBar & NavBar(три кнопки)
		setContent{
			AppScreen()
		}
	}
}

@Composable
fun AppScreen(){
	val scrollBehavior = TopAppBarDefaults.enterAlwaysScrollBehavior()
	
	Column(
		modifier = Modifier
			.fillMaxSize()
			.nestedScroll(scrollBehavior.nestedScrollConnection)
	){
		// CenterAlignedTopAppBar
		// MediumTopAppBar
		// LargeTopAppBar
		TopAppBar(
			modifier = Modifier  
				.clip(RoundedCornerShape(bottomStart = 24.dp)),
			colors = TopAppBarDefaults.largeTopAppBarColors( 
				containerColor = MaterialTheme.colorScheme.primaryContainer,
				titleContentColor = MaterialTheme.colorScheme.onPrimaryContainer, // цвет контрастный primaryContainer (чтоты видно было)
				navigationIconContentColor = Color.Red,
				actionIconContentColor = Color.Red,
				scrolledConteqinerColor = Color.Yellow,
			),
			title = { 
				Box(modifier = Modifier.fillMaxSize(),
					contentAlignment = Alignment.Center){ // ставим Текст в середину
					Text( ... ) 
				}
			},
			navigationIcon = { IconButton() },
			actions = {
				IconButton( onClick = {} ){
					BadgedBox(badge = {
						Badge(modifier.size(10.dp)) {}
					}) {
						Icon( imageVector = Icon.Default.Settings, contentDescription = null)
					}
				}
				IconButton( onClick = {} ){
					Icon( imageVector = Icon.Default.MoreVert, contentDescription = null)
				}
			},
			scrollBehavior = scrollBehavior,
			windowInsets = WindowInsets(0) // ОБНУЛЯЕМ автопадинги. Контент TopAppBar залезет под statusBar
		){} 
		
		LazyColumn(modifier = Modifier.fillMaxSize()){
			items(100){ item ->
				Text( 
					text = "Item #${item + 1}",
					modifier = Modifier.padding(12.dp)
				)
			}
		}
	}
}

```

#### Surface  -  (Material3)
```kotlin
Surface(  // применяет цвета фона в соответствии с текущей темой.
    color = MaterialTheme.colorScheme.background,
    elevation = 4.dp,
    shape = RoundedCornerShape(8.dp)
) {
    // Содержимое Surface, напр. Text и т.д.
}
```
### Компоненты

#### Text - заголовки, параграфы
```kotlin
Text(
	modifier = Modifier
		.fillMaxWidth()      // если соблюсти такую последовательность ->
		.wrapContentWidth()  // -> текст выровняется по центру скрина и займет минимум места.
		.background(colorState.value)
		.cilckable{ isExpanded = !isExpanded },
	maxLines = if(isExpanded) 10 else 1,
	text = textState.value.toString,
	style = MaterialTheme.typography.headlineMedium,
	letterSpacing = 30.sp,
	
)
```
#### Icon - отрисовка .svg
```kotlin
Icon(  
	// bitmap = BitmapFactory.decodeResource(resources, R.drawable.my_image),
	// bitmap = BitmapFactory.decodeFile("/path/to/image.jpg"),
	// bitmap = BitmapFactory.decodeStream(inputStream),
	// bitmap = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888),
	// imageVector = Icons.Outlined.KeyboardArrowLeft,
	painter = painterResource(id = R.drawable.ic_sync),  
	contentDescription = "im4",  
	tint = Color.White    // програмно меняем цвет иконки
	modifier = Modifier
		.size(48.dp)      // кружечек вокруг иконки
		.background(Color.LightGray, CircleShape)
		.padding(8.dp)
) 
```
#### Image - отрисовка .png
```kotlin
Image(  
    painter = painterResource(R.drawable.ghovardhan),  
    contentDescription = "Ghovardhan",
    contentScale = ContentScale.Fit,    // растянуть
	alpha = DefaultAlpha,  
	colorFilter = null,
	modifier = Modifier
		.aspectRatio(1f/1f)             // обрезать квадратом
		.clip(CircleShape)              // обрезать кругом
		.clip(GenericShape{ size, _ ->  // обрезать треугольником
			moveTo(0f, size.height)
			lineTo(size.width / 2, 0f)
			lineTo(size.width, size.height)
		})
)
```

#### AsyncImage - загрузка изображения по ссылке
```kotlin
<uses-permission android:name="android.permission.INTERNET"/>

implementation("io.coil-kt:coil-compose:2.4.0")

AsyncImage(
	model = "https://images.unsplash.com/photo"
	contentDescription = "Ghovardhan",
)
```

#### SubcomposeAsyncImage
```kotlin
<uses-permission android:name="android.permission.INTERNET"/>

implementation("io.coil-kt:coil-compose:2.4.0")

SubcomposeAsyncImage(
	model = "https://images.unsplash.com/photo",
	contentDescription = "Ghovardhan",
	loading = { CircularProgressIndicator() },  // индикация прогресса загрузки.
	error = { Text("Load faild", color = Color.Red) },
)
```

#### Button
```kotlin
Button(
	enabled = true,
	onClick = {}
){ Text(text = "Got It") }

TextButton(onClick = {}){ Text(text = "Got It") }

IconButton(onClick = {}) {  
    Icon(  
	    painter = painterResource(id = R.drawable.ic_sync),  
	    contentDescription = "im4",  
	    tint = Color.White  
    )  
}
```

#### TextField
```kotlin
// state
var textValue: String by remember{ mutableStateOf("") }

OutlinedTextField(
	value = "Qwerty",
	onValueChange = {  
		text = it  // Your logic for handling the value change  
	},  
	modifier = Modifier  
		.fillMaxWidth()  
		.padding(horizontal = 16.dp)  
		.height(56.dp),  
	textStyle = MaterialTheme.typography.bodySmall,  
	placeholder = {  
		Text(text = "Enter text...")  
	},  
	leadingIcon = {  
		Icon(  
			imageVector = Icons.Default.Clear,  
			contentDescription = null,  
			modifier = Modifier.clickable {  
				text = ""  
				keyboardController?.hide()  
			},
		)  
	},  
	trailingIcon = {  
		IconButton(  
		onClick = {  
			focusManager.clearFocus()  
			keyboardController?.hide()  
			// Your logic for handling trailing icon click  
		}) {  
			Icon(  
			imageVector = Icons.Default.ChevronRight,  
			contentDescription = null  
			)  
		}  
	},  
	isError = text.length < 6, // For example, show error if length is less than 6  
	singleLine = true,  
	keyboardOptions = KeyboardOptions(  
		keyboardType = KeyboardType.Text,  
		imeAction = ImeAction.Done  
	),  
	keyboardActions = KeyboardActions(  
		onDone = {  
			// Your logic for handling "Done" action  
		}  
	),  
	visualTransformation = PasswordVisualTransformation(),  
	colors = TextFieldDefaults.colors(  
		unfocusedContainerColor = Color.DarkGray,
		cursorColor = Color.Black,  
		...
	)
)
```

#### Checkbox
```kotlin
var chbValue: Boolean by remember{ mutableStateOf(false) }

OutlinedTextField(
	checked = chbValue,
	onCheckedChange = { newValue -> chbValue = newValue}
)
```

#### AlertDialog
```kotlin
AlertDialog(  
    onDismissRequest = {},
    confirmButton = { TextButton(onClick = {}){ Text(text = "Ok") } },
    dismissButton = { TextButton(onClick = {}){ Text(text = "Cancel") } },
    title = { 
	    Column(modifier = Modifier.fillMaxWidth()){
		    Text(text="Введите название города:")
		    TextField(value="Text", onValueChange={})
	    }
	}
)
```

#### TabRow
```kotlin
val tabList = listOf("HOURS", "DAYS")

TabRow(  
    selectedTabIndex = 0,
    indicator = {  },
    backgroundColor = Color.Blue,
) {
	tabList.forEachIndexed{
		Tab(
			selected = false,
			onClick = {},
			text = {
				Text(text = "SomeText")
			}
		)
	}
}
```

#### Pager (типа ViewPager)
```kotlin

api "com.google.accompanist-pager:0.19.0"
api "com.google.accompanist-pager-indicators:0.19.0"

val tabList = listOf("HOURS", "DAYS")
val pagerState = rememberPagerState()
val tabIndex = pagerSate.currentPage
val coroutineScope = rememberCoroutineScope()

TabRow(  
    selectedTabIndex = tabIndex,
    indicator = { pos ->
	    TabRowDefaults.Indicator(
		    Modifier.pagerTabIndicatorOffset(pagerState,pos)
	    ) 
	},
    backgroundColor = Color.Blue,
) {
	tabList.forEachIndexed{
		Tab(
			selected = false,
			onClick = {
				coroutineScope.launch{
					pagerState.animateScrollToPage(index)
				}
			},
			text = {
				Text(text = "SomeText")
			}
		)
	}
	
}
HorizontalPager(
	count = tabList.size,
	state = pagerState,
	modifier = Modifier.weight(1.0f
){ index ->
	LazyColumn(...){
		items(15){
			CustomListItem()
		}
	}
}
```




#### VIEW_MODEL
```kotlin  
import androidx.lifecycle.ViewModel
class UserViewModel(private val repository: UserRepository) : ViewModel() {  
	  
    fun sayHello(name : String) : String{  
        val foundUser = repository.findUser(name)  
        return foundUser?.let { "Hello '$it' from $this" } ?: "User '$name' not found!"  
    }  
}


import org.koin.androidx.compose.koinViewModel
fun CustomScreen(userName: String, viewModel: CustomViewModel = koinViewModel()){
	Text(text = viewModel.sayHello(userName))
}
```


# Реализация в проекте:

## MainActivity
```kotlin
override fun onCreate(savedInstanceState: Bundle?) {  
    super.onCreate(savedInstanceState)  
    setContent {  // рисует все в левом верхнем углу
        AppCompatTheme {  
            MukundaNavGraph()  
        }  
    }
}
```

## MukundaNavGraph.kt
```kotlin
@Composable
fun MukundaNavGraph(
    modifier: Modifier = Modifier,
    navController: NavHostController = rememberNavController(),
    coroutineScope: CoroutineScope = rememberCoroutineScope(),
    drawerState: DrawerState = rememberDrawerState(initialValue = DrawerValue.Closed),
    startDestination: String = MukundaDestinations.HOME_ROUTE,
    navActions: MukundaNavigationActions = remember(navController) {
        MukundaNavigationActions(navController)
    }
) {
    val currentNavBackStackEntry by navController.currentBackStackEntryAsState()
    val currentRoute = currentNavBackStackEntry?.destination?.route ?: startDestination

    NavHost(
        navController = navController,
        startDestination = startDestination,
        modifier = modifier
    ) {
        composable(
            MukundaDestinations.HOME_ROUTE,
        ) { entry ->
            AppModalDrawer(drawerState, currentRoute, navActions) {
                PicturesScreen() //custom Composable function
            }
        }
        composable(MukundaDestinations.STATISTICS_ROUTE) {
            AppModalDrawer(drawerState, currentRoute, navActions) {
                StatisticsScreen(openDrawer = { coroutineScope.launch { drawerState.open() } })
            }
        }
    }
}
```

#### PicturesScreen.kt
```kotlin 
@Composable  
fun PicturesScreen() {  
	
	val myState = remember{ //теперь, если значение изменится - textView перересуется.
		mutableStateOf(value = "ArtSam World")
	}
	 
	val otherState by remember{ 
		mutableStateOf(false)
	}
	
    Row(modifier = Modifier.fillMaxSize()) {  
        PictureGridItem("\"Ghovardhan\"", "$100.00")  //custom Composable function same as PicturesScreen()
        PictureGridItem("\"Ghovardhan\"", "$100.00")  
        Text(maxLines = 10, text = myState.value)
    }   
}
```
//used in MukundaNavGraph.kt

## MukundaNavigation.kt
```kotlin
/**  
 * Screens used in [MukundaDestinations]  
 */  
private object MukundaScreens {  
    const val PICTURES_SCREEN = "pictures"  
    const val STATISTICS_SCREEN = "statistics"  
    const val PICTURE_DETAIL_SCREEN = "picture"  
}  
  
/**  
 * Arguments used in [MukundaDestinations] routes */object MukundaDestinationsArgs {  
    const val PICTURE_ID_ARG = "taskId"  
    const val TITLE_ARG = "title"  
}  
  
/**  
 * Destinations used in the [MainActivity]  
 */  
object MukundaDestinations {  
    const val HOME_ROUTE = "$PICTURES_SCREEN?"  
    const val STATISTICS_ROUTE = STATISTICS_SCREEN  
    const val PICTURE_DETAILS_ROUTE = "$PICTURE_DETAIL_SCREEN/{$PICTURE_ID_ARG}"  
}  
  
/**  
 * Models the navigation actions in the app. */class MukundaNavigationActions(private val navController: NavHostController) {  
  
    fun navigateToTasks(userMessage: Int = 0) {  
        val navigatesFromDrawer = userMessage == 0  
        navController.navigate(PICTURES_SCREEN) {  
            popUpTo(navController.graph.findStartDestination().id) {  
                inclusive = !navigatesFromDrawer  
                saveState = navigatesFromDrawer  
            }  
            launchSingleTop = true  
            restoreState = navigatesFromDrawer  
        }  
    }  
  
    fun navigateToStatistics() {  
        navController.navigate(MukundaDestinations.STATISTICS_ROUTE) {  
            // Pop up to the start destination of the graph to  
            // avoid building up a large stack of destinations            // on the back stack as users select items            popUpTo(navController.graph.findStartDestination().id) {  
                saveState = true  
            }  
            // Avoid multiple copies of the same destination when  
            // reselecting the same item            launchSingleTop = true  
            // Restore state when reselecting a previously selected item  
            restoreState = true  
        }  
    }  
  
    fun navigateToPictureDetails(taskId: String) {  
        navController.navigate("$PICTURE_DETAIL_SCREEN/$taskId")  
    }  
}
```

